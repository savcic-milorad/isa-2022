import { HttpErrorResponse, HttpStatusCode } from "@angular/common/http";
import { Injectable } from "@angular/core";
import { catchError, Observable, throwError } from "rxjs";
import { IdentityService } from "../../shared/transfusion-api-client/api/identity.service";
import { CreateDonorCommand } from "../../shared/transfusion-api-client/model/models";
import { AnonymousState } from "./state/anonymous.state";

@Injectable({
  providedIn: 'root'
})
export class AnonymousFacade {

  constructor(private identityApi: IdentityService, private anonymousState: AnonymousState) { }

  isLoading$(): Observable<boolean> {
    return this.anonymousState.isLoading$();
  }

  register(command: CreateDonorCommand) {
    this.anonymousState.setIsLoading(true);

    this.identityApi.apiIdentityDonorsPost(command)
    .pipe(
      catchError(this.handleError)
    )
    .subscribe(
    {
      next: (val) => {
        this.anonymousState.setCreatedDonor(val.body ?? {});
      },
      error: (err: Error) => {
        this.anonymousState.setIsLoading(false);
        
        console.error(`Error from observer: ${err.message}`);
      },
      complete: () => {
        console.log('COMPLETE');
        this.anonymousState.setIsLoading(false);
      }
    });
  }

  // login(command: LoginCommand) {
  //   this.anonymousState.setIsLoading(true);

  //   this.identityApi.(command)
  //   .pipe(
  //     catchError(this.handleError)
  //   )
  //   .subscribe(
  //   {
  //     next: (val) => {
  //       this.anonymousState.setCreatedDonor(val.body ?? {});
  //     },
  //     error: (err: Error) => {
  //       this.anonymousState.setIsLoading(false);
        
  //       console.error(`Error from observer: ${err.message}`);
  //     },
  //     complete: () => {
  //       console.log('COMPLETE');
  //       this.anonymousState.setIsLoading(false);
  //     }
  //   });
  // }

  private handleError(error: HttpErrorResponse): Observable<never> {
    if (error.status === 0) {
      return throwError(() => new Error(`A network or client error occurred due to:\n${JSON.stringify(error.error)}`));
    } 
    else if(error.status === HttpStatusCode.NotFound) {
      return throwError(() => new Error(`Request could not be processed due to:\n${JSON.stringify(error.error)}`));
    }
    else if(error.status === HttpStatusCode.BadRequest) {
      return throwError(() => new Error(`Request could not be processed due to:\n${JSON.stringify(error.error)}`));
    }
    else if(error.status === HttpStatusCode.InternalServerError) {
      return throwError(() => new Error('Server side error occured.'));
    }
    
    return throwError(() => new Error(`Error message with unknown code occured: ${error.error}`));
  }

  // getCenterSearchParameters$(): Observable<CenterSearchParameters> {
  //   // state can be projected, or result from combination of multiple observables, or cached
  //   return this.anonymousState.getCenterSearchParameters$();
  // }

  // TODO
  // loadCashflowCategories() {
  //   return this.centerApi...
  // }

  // optimistic update
  // 1. update UI state
  // 2. call API
  // addCenter(addedCenterInStateWithoutId: Center) {
    
  //   // state update
  //   this.anonymousState.addCenter(addedCenterInStateWithoutId);

  //   // api call
  //   this.api.createCenter(addedCenterInStateWithoutId)
  //     .subscribe(
  //       (addedCenterFromApiWithId: Center) => {
  //         // success callback - we have id generated by the server, let's update the state
  //         this.anonymousState.updateCenter(addedCenterInStateWithoutId, addedCenterFromApiWithId);
  //       },
  //       (error: any) => {
  //         // error callback - we need to rollback the state change
  //         this.anonymousState.removeCenter(addedCenterInStateWithoutId);
  //         console.log(error);
  //       }
  //     );
  // }

  // pessimistic update
  // 1. call API
  // 2. update UI state
  // updateCashflowCategory(center: Center) {
  //   this.anonymousState.setUpdating(true);
  //   this.centerApi.updateCenter(center)
  //     .subscribe(
  //       () => this.anonymousState.updateCenter(center),
  //       (error) => console.log(error),
  //       () => this.anonymousState.setUpdating(false)
  //     );
  // }
}